package malicious

import (
	"testing"

	"github.com/celestiaorg/celestia-app/pkg/wrapper"
	"github.com/celestiaorg/celestia-app/test/util/testfactory"
	"github.com/stretchr/testify/require"
	tmrand "github.com/tendermint/tendermint/libs/rand"
)

// TestOutOfOrderNMT tests that the malicious NMT implementation is able to
// generate the same root as the ordered NMT implementation when the leaves are
// added in the same order, is able to generate roots when leaves are out of
// order.
func TestOutOfOrderNMT(t *testing.T) {
	squareSize := uint64(64)
	c := NewConstructor(squareSize)
	goodConstructor := wrapper.NewConstructor(squareSize)

	orderedTree := goodConstructor(0, 0)
	maliciousOrderedTree := c(0, 0)
	maliciousUnorderedTree := c(0, 0)
	data := testfactory.GenerateRandNamespacedRawData(64)

	// compare the roots generated by pushing and manually adding leaves using
	// ordered data
	for _, d := range data {
		orderedTree.Push(d)
		maliciousOrderedTree.Push(d)
	}

	goodOrderedRoot, err := orderedTree.Root()
	require.NoError(t, err)
	malOrderedRoot, err := maliciousOrderedTree.Root()
	require.NoError(t, err)
	require.Equal(t, goodOrderedRoot, malOrderedRoot)

	// test the new tree with unordered data
	for i := range data {
		j := tmrand.Intn(len(data))
		data[i], data[j] = data[j], data[i]
	}

	for _, d := range data {
		maliciousUnorderedTree.Push(d)
	}

	root, err := maliciousUnorderedTree.Root()
	require.NoError(t, err)
	require.Len(t, root, 90)                   // two namespaces + 32 bytes of hash = 90 bytes
	require.NotEqual(t, goodOrderedRoot, root) // quick sanity check to ensure the roots are different
}
