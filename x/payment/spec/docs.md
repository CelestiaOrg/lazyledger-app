# `x/payment`

## Abstract

The payment module enables users to pay for arbitrary data to be published to the Celestia blockchain. Users create a single `MsgWirePayForData` transaction that is composed of:

1. `Message`: the data they wish to publish
2. `MessageNameSpaceId`: the namespace they wish to publish to
3. `MessageShareCommitment`: a signature and a commitment over their data when encoded into shares

After the `MsgWirePayForData` transaction is submitted to the network, a block producer malleates their transaction into a `MsgPayForData` which doesn't include their data (a.k.a message). Both components get included in the data square in different namespaces: the `MsgPayForData` gets included in the transaction namespace and the associated data gets included in the namespace the user specified in the original `MsgWirePayForData`. Further reading: [Message Block Layout](https://github.com/celestiaorg/celestia-specs/blob/master/src/rationale/message_block_layout.md)

After a block has been created, the user can verify that their data was included in a block via a message inclusion proof. A message inclusion proof the `MessageShareCommitment` in the original `MsgWirePayForData` and subtree roots of the block's data square to proove to the user that the shares that compose their original data do in fact exist in a particular block.

## State

The payment module doesn't maintain it's own state.

When a PayForData message is processed, it consumes gas based on the message size.

## Messages

- [`MsgWirePayForData`](https://github.com/celestiaorg/celestia-app/blob/b4c8ebdf35db200a9b99d295a13de01110802af4/x/payment/types/tx.pb.go#L32-L40) is created and signed by the user but it never ends up on-chain. Instead, it is "malleated" into it's component parts: data and a `MsgPayForData` message.
- [`MsgPayForData`](https://github.com/celestiaorg/celestia-app/blob/b4c8ebdf35db200a9b99d295a13de01110802af4/x/payment/types/tx.pb.go#L208-L216) is one output of the malleation process. It contains metadata from the original `MsgWirePayForData` but not the associated data.

## Events

- [`NewPayForDataEvent`](https://github.com/celestiaorg/celestia-app/pull/213/files#diff-1ce55bda42cf160deca2e5ea1f4382b65f3b689c7e00c88085d7ce219e77303dR17-R21) is emitted with the signer's address and size of the message that is paid for.

## Parameters

There are no parameters yet, but we might add

- BaseFee
- SquareSize

### Usage

```shell
celestia-app tx payment payForData <hex encoded namespace> <hex encoded data> [flags]
```

### Programmatic Usage

There are tools to programmatically create, sign, and broadcast `MsgWirePayForData`s

```go
// create the raw WirePayForData transaction
wpfdMsg, err := apptypes.NewWirePayForData(block.Header.NamespaceId, message, 16, 32, 64, 128)
if err != nil {
    return err
}

// we need to create a signature for each `MsgPayForData`s that
// could be generated by the block producer
// to do this, we create a custom `KeyringSigner` to sign messages programmatically
// which uses the standard cosmos-sdk `Keyring` to sign each `MsgPayForData`
keyringSigner, err := NewKeyringSigner(keyring, "keyring account name", "chain-id-1")
if err != nil {
    return err
}

// query for account information necessary to sign a valid tx
err = keyringSigner.QueryAccount(ctx, grpcClientConn)
if err != nil {
    return err
}

// generate the signatures for each `MsgPayForData` using the `KeyringSigner`,
// then set the gas limit for the tx
gasLimOption := types.SetGasLimit(200000)
err = pfdMsg.SignShareCommitments(keyringSigner, gasLimOption)
if err != nil {
    return err
}

// Build and sign the final `WirePayForData` tx that now contains the signatures
// for potential `MsgPayForData`s
signedTx, err := keyringSigner.BuildSignedTx(
    gasLimOption(signer.NewTxBuilder()),
    wpfdMsg,
)
if err != nil {
    return err
}
```

<!-- markdownlint-enable MD010 -->

### How is the `MessageShareCommitment` generated?

1. Split the message into shares of size `appconsts.ShareSize`
1. Determine the `msgMinSquareSize` (the minimum square size the message can fit into). This is done by taking the number of shares from the previous step and rounding up to the next perfect square that is a power of two.
1. Arrange the shares into a Merkle mountain range where each tree in the mountain range has a maximum size of the `msgMinSquareSize`.
1. Take the roots of the trees in the Merkle mountain range and create a new Merkle tree.
1. The message share commitment is the Merkle root of the Merkle tree from the previous step.
