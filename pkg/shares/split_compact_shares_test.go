package shares

import (
	"bytes"
	"testing"

	"github.com/celestiaorg/celestia-app/pkg/appconsts"
	"github.com/stretchr/testify/assert"
	coretypes "github.com/tendermint/tendermint/types"
)

func TestCount(t *testing.T) {
	type testCase struct {
		transactions   []coretypes.Tx
		wantShareCount int
	}
	testCases := []testCase{
		{transactions: []coretypes.Tx{}, wantShareCount: 0},
		{transactions: []coretypes.Tx{[]byte{0}}, wantShareCount: 1},
		{transactions: []coretypes.Tx{bytes.Repeat([]byte{0}, 100)}, wantShareCount: 1},
		{transactions: []coretypes.Tx{bytes.Repeat([]byte{0}, appconsts.ContinuationCompactShareContentSize+1)}, wantShareCount: 2},
		{transactions: []coretypes.Tx{bytes.Repeat([]byte{0}, appconsts.ContinuationCompactShareContentSize*2+1)}, wantShareCount: 3},
	}
	for _, tc := range testCases {
		css := NewCompactShareSplitter(appconsts.TxNamespaceID, appconsts.ShareVersionZero)
		for _, transaction := range tc.transactions {
			css.WriteTx(transaction)
		}
		got := css.Count()
		if got != tc.wantShareCount {
			t.Errorf("count got %d want %d", got, tc.wantShareCount)
		}
	}
}

func TestExport_write(t *testing.T) {
	type testCase struct {
		name       string
		want       []Share
		writeBytes [][]byte
	}

	oneShare, _ := zeroPadIfNecessary([]byte{
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, // namespace id
		0x1,                // info byte
		0x0, 0x0, 0x0, 0x1, // sequence len
		0x0, 0x0, 0x0, 17, // reserved bytes
		0xf, // data
	}, appconsts.ShareSize)

	firstShare, _ := zeroPadIfNecessary([]byte{
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, // namespace id
		0x1,                // info byte
		0x0, 0x0, 0x2, 0x0, // sequence len
		0x0, 0x0, 0x0, 17, // reserved bytes
		0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, // data
	}, appconsts.ShareSize)

	continuationShare, _ := zeroPadIfNecessary([]byte{
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, // namespace id
		0x0,                // info byte
		0x0, 0x0, 0x0, 0x0, // reserved bytes
		0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, // data
	}, appconsts.ShareSize)

	testCases := []testCase{
		{
			name: "empty",
			want: []Share{},
		},
		{
			name: "one share with small sequence len",
			want: []Share{
				oneShare,
			},
			writeBytes: [][]byte{{0xf}},
		},
		{
			name: "two shares with big sequence len",
			want: []Share{
				firstShare,
				continuationShare,
			},
			writeBytes: [][]byte{bytes.Repeat([]byte{0xf}, 512)},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			css := NewCompactShareSplitter(appconsts.TxNamespaceID, appconsts.ShareVersionZero)
			for _, bytes := range tc.writeBytes {
				css.write(bytes)
			}
			got, _ := css.Export()
			assert.Equal(t, tc.want, got)
		})
	}
}

func TestExport(t *testing.T) {
	type testCase struct {
		name string
		txs  []coretypes.Tx
		want map[coretypes.TxKey]ShareRange
	}

	txOne := coretypes.Tx{0x1}
	txTwo := coretypes.Tx(bytes.Repeat([]byte{2}, 600))
	txThree := coretypes.Tx(bytes.Repeat([]byte{3}, 1000))
	exactlyOneShare := coretypes.Tx(bytes.Repeat([]byte{4}, subtractDelimLen(appconsts.FirstCompactShareContentSize)))
	exactlyTwoShares := coretypes.Tx(bytes.Repeat([]byte{5}, subtractDelimLen(appconsts.FirstCompactShareContentSize+appconsts.ContinuationCompactShareContentSize)))

	testCases := []testCase{
		{
			name: "empty",
			txs:  []coretypes.Tx{},
			want: map[coretypes.TxKey]ShareRange{},
		},
		{
			name: "txOne occupies shares 0 to 0",
			txs: []coretypes.Tx{
				txOne,
			},
			want: map[coretypes.TxKey]ShareRange{
				txOne.Key(): {0, 0},
			},
		},
		{
			name: "txTwo occupies shares 0 to 1",
			txs: []coretypes.Tx{
				txTwo,
			},
			want: map[coretypes.TxKey]ShareRange{
				txTwo.Key(): {0, 1},
			},
		},
		{
			name: "txThree occupies shares 0 to 2",
			txs: []coretypes.Tx{
				txThree,
			},
			want: map[coretypes.TxKey]ShareRange{
				txThree.Key(): {0, 2},
			},
		},
		{
			name: "txOne occupies shares 0 to 0, txTwo occupies shares 0 to 1, txThree occupies shares 1 to 3",
			txs: []coretypes.Tx{
				txOne,
				txTwo,
				txThree,
			},
			want: map[coretypes.TxKey]ShareRange{
				txOne.Key():   {0, 0},
				txTwo.Key():   {0, 1},
				txThree.Key(): {1, 3},
			},
		},

		{
			name: "exactly one share occupies shares 0 to 0",
			txs: []coretypes.Tx{
				exactlyOneShare,
			},
			want: map[coretypes.TxKey]ShareRange{
				exactlyOneShare.Key(): {0, 0},
			},
		},
		{
			name: "exactly two shares occupies shares 0 to 1",
			txs: []coretypes.Tx{
				exactlyTwoShares,
			},
			want: map[coretypes.TxKey]ShareRange{
				exactlyTwoShares.Key(): {0, 1},
			},
		},
		{
			name: "two shares followed by one share",
			txs: []coretypes.Tx{
				exactlyTwoShares,
				exactlyOneShare,
			},
			want: map[coretypes.TxKey]ShareRange{
				exactlyTwoShares.Key(): {0, 1},
				exactlyOneShare.Key():  {2, 2},
			},
		},
		{
			name: "one share followed by two shares",
			txs: []coretypes.Tx{
				exactlyOneShare,
				exactlyTwoShares,
			},
			want: map[coretypes.TxKey]ShareRange{
				exactlyOneShare.Key():  {0, 0},
				exactlyTwoShares.Key(): {1, 2},
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			css := NewCompactShareSplitter(appconsts.TxNamespaceID, appconsts.ShareVersionZero)
			for _, tx := range tc.txs {
				css.WriteTx(tx)
			}

			_, got := css.Export()
			assert.Equal(t, tc.want, got)
		})
	}
}

// subtractDelimLen subtracts the delimiter size from numBytesDelimited. This is
// useful for determining the size of a tx prior to it being prepended with a
// delimiter.
func subtractDelimLen(numBytesDelimited int) (numBytesUndelimited int) {
	return numBytesDelimited - DelimLen(uint64(numBytesDelimited))
}
